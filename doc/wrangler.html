<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module wrangler</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body bgcolor="white">

<h1>Module wrangler</h1>
The collection of refactorings supported by Wrangler.
<p>Copyright © 2006-2008 Huiqing Li, Simon Thompson
 </p>
<ul><li><a href="#description">Description</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>
<p><b>Version:</b>  0.2</p>
<p><b>Authors:</b> Huiqing Li (<a href="mailto:hl@kent.ac.uk"><tt>hl@kent.ac.uk</tt></a>) [<em>web site:</em> <tt><a href="http://www.cs.kent.ac.uk/projects/forse" target="_top">http://www.cs.kent.ac.uk/projects/forse</a></tt>].</p>

<h2><a name="description">Description</a></h2>The collection of refactorings supported by Wrangler.
 
<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1"><tr><td valign="top"><a href="#generalise-4">generalise/4</a></td><td>Generalise a function definition by selecting a sub-expression of its right-hand  
side and making this the value of a new argument added to the definition of the function.</td></tr>
<tr><td valign="top"><a href="#move_fun-6">move_fun/6</a></td><td>Move a function definition from its current module to another module.</td></tr>
<tr><td valign="top"><a href="#rename_fun-5">rename_fun/5</a></td><td>Rename a function name with a user-supplied new name.</td></tr>
<tr><td valign="top"><a href="#rename_mod-3">rename_mod/3</a></td><td>Rename a module name with a user-supplied new name.</td></tr>
<tr><td valign="top"><a href="#rename_mod_batch-3">rename_mod_batch/3</a></td><td>Rename a collect of module names in batch mode.</td></tr>
<tr><td valign="top"><a href="#rename_var-5">rename_var/5</a></td><td>Rename a variable name with a user-supplied new name.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3><a name="generalise-4">generalise/4</a></h3>
<p><tt>generalise(FileName::<a href="#type-filename">filename()</a>, Start::Pos, End::Pos, ParName::string()) -&gt; term()</tt>
<ul><li><tt>Pos = {integer(), integer()}</tt></li></ul></p>
<p><p>Generalise a function definition by selecting a sub-expression of its right-hand  
side and making this the value of a new argument added to the definition of the function.  
The sub-expression becomes the actual parameter at the call sites.</p>
 
  <p> To apply this refactoring, highlight the expression first, then  select
  <em> Generalise Function Definition </em> from the <em>Refactor</em> menu, after
  that the refactorer will prompt to enter the parameter name in the mini-buffer. </p>
 
  <p> Here is an example of generalisation, in which the function <code> add_one </code> defined
  on the left-hand side is generalised on the expression <code> 1 </code>, and the result is
  shown on the right-hand side.
 
         <pre>                -module (test).                          -module (test).
                -export([f/1]).                          -export([f/1]).
 
                add_one ([H|T]) -&gt;                       add_one (N, [H|T]) -&gt;
                   [H+1 | add_one(T)];                      [H+N | add_one(N,T)];
                add_one ([]) -&gt; [].                      add_one (N, []) -&gt; [].
 
                f(X) -&gt; add_one(X).                      f(X) -&gt; add_one(1,X)</pre>
   </p>
 
  <p> In the case that the selected expression has a side-effect, the refactorer will wrap this expression
  in an function expression before passing it at the actual parameter to the call-sites. This is illustrated
  in the following example, in which function <code>repeat/1</code> is generalised on the expression
  <code>io:format("Hello\n")</code>.
 
          <pre>                -module (test).                          -module (test).
                -export([f/0]).                          -export([f/0]).
 
                repeat(0) -&gt; ok;                         repeat(A, 0) -&gt; ok;
                repeat(N) -&gt;                             repeat(A, N) -&gt;
                  io:format("Hello\n"),                    A( ),
                  repeat(N-1).                             repeat(A,N-1).
 
                f() -&gt; repeat(5).                        f( ) -&gt;
                                                            repeat (fun( )-&gt;io:format ("Hello\n") end, 5).</pre>
  </p>
 
  <p> This refactoring <em>only </em> affects the module in which the refactoring is initialised. In the case that
  the generalised function is exported by the module, an auxiliary function will be created
  to wrap the generalised function up, so that the module's interface is not changed.
  </p>
  <p> The following <em> side-conditions </em> apply to this refactoring:
  <li> Suppose the function to be generalised is <code>foo/n </code>, then <code>foo/n+1</code> should not
  be in scope before the generalisation;</li>
  <li> The selected expression should not contain any locally declared variable(s), unless the selected expression
  has side effect, in which case the locally declared variables will become the parameters of the function expression.
  </li>
  <li> The user-provided parameter name should not conflict with the existing parameters or
  change the semantics of the function to be generalised. </li>
  </p></p>

<h3><a name="move_fun-6">move_fun/6</a></h3>
<p><tt>move_fun(FileName::<a href="#type-filename">filename()</a>, Line::integer(), Col::integer(), ModName::string(), CreateNewFile::<a href="#type-boolean">boolean()</a>, SearchPaths::[string()]) -&gt; term()</tt></p>
<p>Move a function definition from its current module to another module.
  <p> To apply this refactoring, point the cursor at the function definition, then
  select <em> Move Definition to Another Module</em> from the <em> Refactor </em> menu,
  after that the refactorer will prompt to enter the target module name in the mini-buffer.
  </p>
  <p> This refactoring has a global effect, i.e., it affects all the modules in which
      the function is imported/used.
  </p>
  <p> This refactoring assumes that an erlang module name always matches it file name.
  </p>
  <p> Suppose we move functin <em> foo/n </em> from its current module <em> M </em>
      to module <em> N </em>, then the following <em> side-conditions </em> apply to
      this refactoring:
  <li> If <em> foo/n </em> is already in scope in module <em> N </em>, then its defining
       module should be  <em> M </em>.
  </li>
  <li> Function <em> foo/n </em> should not contain any uses of <em> implicit fun expressions </em> (Note: move a
  collection of modules together to another module will be supported by another refactoring).
  </li>
  </p></p>

<h3><a name="rename_fun-5">rename_fun/5</a></h3>
<p><tt>rename_fun(FileName::<a href="#type-filename">filename()</a>, Line::integer(), Col::integer(), NewName::string(), SearchPaths::[string()]) -&gt; term()</tt></p>
<p>Rename a function name with a user-supplied new name.
  <p> To apply this refactoring, point the cursor to any occurrence of this
  function name, then select <em> Rename Function Name </em> from the <em> Refactor </em> menu,
  after that the refactorer will prompt to enter  the new function name in the mini-buffer.
  </p>
  <p>
  When renaming an exported function name, this refactoring has a global effect, i.e.,
  it affects all those modules in which this function is imported/used.
  </p>
  <p> The following <em> side-conditions </em> apply to this refactoring:
  <li> The new function name should not cause confliction with any of the functions which are in scope in the
  current module;</li>
  <li> In the case that the function to be renamed is imported by another module, the new function name (with the same
  arity) should not be already in scope (either defined or imported) in that module. </li>
  </p></p>

<h3><a name="rename_mod-3">rename_mod/3</a></h3>
<p><tt>rename_mod(FileName::<a href="#type-filename">filename()</a>, NewName::string(), SearchPaths::[string()]) -&gt; term()</tt></p>
<p>Rename a module name with a user-supplied new name.
  <p> To apply this refactoring, point the cursor to anywhere in the module to be renamed, then select
  <em> Rename Module Name </em> from the <em> Refactor </em> menu, after that, the refactorer will prompt to enter
  the new module name in the mini-buffer.
  </p>
  <p> This refactoring has a global effect, i.e., it affects all those modules in which the module to be renamed is
  imported, or used as a module qualifier.
  </p>
  <p>
  The following <em> side-conditions </em> apply to this refactoring:
  <li> The new module name should be a fresh name. </li>
  <li> This refactoring assume that the file basename is always the same as the module name, therefore this
  refactoring changes the filename as well. </li>
  </p></p>

<h3><a name="rename_mod_batch-3">rename_mod_batch/3</a></h3>
<p><tt>rename_mod_batch(OldNamePattern::string(), NewNamePattern::string(), SearchPaths::[string()]) -&gt; ok | {error, string()}</tt></p>
<p>Rename a collect of module names in batch mode.
  <p> This refactoring is supposed to be run from the Erlang shell. For example,
  to rename all those module names which match the regular expression "foo_*" to
  "foo_*_1_0" in the directory <code> c:/wrangler/test </code>, just type the following command:
  <code> wrangler:rename_mod_batch("foo_*, "foo_*_1_0", ["c:/wrangler/test"]) </code>.
  </p>
  <p> This refactoring has a global effect. </p>
  <p> The following <em> side-conditions </em> apply to this refactoring:
  <li> The new module names should not conflict with each other, or any existing module names
  in the same scope which will not be renamed. </li>
  <li> This refactorings assumes that the file basename is always the same as the module name. </li>
  </p></p>

<h3><a name="rename_var-5">rename_var/5</a></h3>
<p><tt>rename_var(FileName::<a href="#type-filename">filename()</a>, Line::integer(), Col::integer(), NewName::string(), SearchPaths::[string()]) -&gt; term()</tt></p>
<p>Rename a variable name with a user-supplied new name.
  <p> To apply this refactoring, point the cursor to  any occurrence of this variable, then select
  <em> Rename Variable Name </em> from the <em> Refactor </em> menu, after that the refactorer will prompt
  to enter the new parameter name in the mini-buffer.
  </p>
  <p> This refactoring has a local effect, i.e., it only affects the function in which the refactoring is initialised.
  </p>
  <p> The following <em> side-conditions </em> apply to this refactoring:
  <li> The new variable name should not conflict with any of the declared variable names in the same scope;</li>
  <li> The new name should not shadow any of the existing variables in the outer scopes, or be shadowed by any of
  of existing variables in the inner scopes, i.e., renaming to the new name should not change the semantics of the
  program.</li>
  </p></p>
</body>
</html>
