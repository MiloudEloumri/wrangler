<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module refac_api</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module refac_api</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>  
This module defines the API exposed by Wrangler for users to compose their  
own refactoring or code inspection functions.

<p><b>Version:</b> 0.1</p>
<p><b>Authors:</b> Huiqing Li (<a href="mailto:H.Li@kent.ac.uk"><tt>H.Li@kent.ac.uk</tt></a>).</p>

<h2><a name="description">Description</a></h2><p>  
This module defines the API exposed by Wrangler for users to compose their  
own refactoring or code inspection functions. A refactoring consist of  
two parts: program analysis and program transformation. Both program analysis  
and program transformation involves various AST traversals and manipulations,  
and requires deep knowledge of the AST representation details. To make the  
processing of writing a refactoring easier, through this refactoring API, we  
aim to provide a template and rule based program analysis and transformation  
framework to allow users to express their own program transformation in  
a very concise way. This is achieved through the following aspects:</p>
 
  <p>-- The use of code templates to make the composition/decomposition of     
of AST nodes straightforward.</p>
 
  <p>-- The use of template-based transformation rules to allow concise     
representation of transformations.</p>
 
  <p>-- Context information annotated to each AST node to make the program     
analysis easier to implement.</p>
 
  <p>-- A collect of predefined macros and API functions to capture the     
most frequently used functionalities when writing a refactoring.</p>
 
  <p>-- A refactoring behaviour <code>gen_refac</code> to provide a high-level abstraction     
of the logic work-flow of a refactoring process.</p>
 
  Some macros:
 <ul>
 <li><p> 
?T(TemplateStr).</p>
 
 <p>?T(TemplateStr) denotes a template code fragment. A template code fragment
  is a string
 representing an Erlang expression, function, or a function clause.
  Both object variables and meta variables can be
  used in a template string. Variable names ending with <code>@</code>, <code>@</code><code>@</code>, or <code>@</code><code>@</code><code>@</code>
  are meta-variables; and variable names not ending with <code>@</code> are object
  variables. A meta variable ending with only one <code>@</code> is a place holder
  for a single program entity which maps to a single AST tree; whereas
  a meta variable ending with <code>@</code><code>@</code> represents a list of program entities
  seperated by comma, which map to a list of AST trees; a meta variable
  ending with <code>@</code><code>@</code><code>@</code> is only used for writing templates that match
  a function with arbitray function clauses or a clause with arbitray
  clause bodies. For example <code>?T("f@(Args@</code><code>@</code><code>@</code><code>) when Guard@</code><code>@</code><code>@</code><code>-&gt; Body@</code><code>@</code><code>@</code><code>.")</code> can be  
used to match function definitions with arbitray number of function  
clauses.</p>
 
 </li>
 
 <li><p> 
?RULE(TemplateBefore, TemplateAfter, Cond).</p>
 
  <p>If the AST node represented by <code>TemplateBefore</code> pattern matches with the
  current AST node, and <code>Cond</code> evaluates to <code>true</code>, then transform the node
  according to <code>TemplateAfter</code>. When a code template pattern matches to an
  AST nodes, each meta variable in the template code is bound to an AST
  node, and meta variables with the same name should always map to AST nodes
  that are semantically the same. A special meta variable names <code>_@This</code> is
  implicitly bound to the whole AST node that matches the code template.
  All these meta-variables are visible, and can be used, in <code>TemplateAfter</code> and
  <code>Cond</code>.</p>
 
 </li>
 <li><p> 
?COLLECT(Template, CollectorFun, Cond, Scope).</p>
 
  For every AST node in <code>Scope</code> that pattern matches the AST represented by <code>Template</code>, if
  <code>Cond</code> evaluates to <code>true</code>, then information about this node is collected using
  the function specified by <code>CollectorFun</code>. <code>Scope</code> can be an AST or a list of Erlang
  files/directories, and in the latter case, each Erlang file included is parsed into
  an AST first.
 </li>
 <li><p> 
?COLLECT_LOC(Template, CollectorFun, Cond, Scope).</p>
 
  <p>For every AST node in <code>Scope</code> that pattern matches the AST represented by <code>Template</code>, if
  <code>Cond</code> evaluates to <code>true</code>, then the location information of this node in the format of
  <code>{filename(), {pos(),pos()}}</code> is collected. <code>Scope</code> should list of Erlang  
files/directories.</p>
 
 </li>
 <li><p> 
?EQUAL(Tree1, Tree2).</p>
 
  <p>Returns <code>true</code> if <code>Tree1</code> and <code>Tree2</code> are syntactically the same up to normalization.  
The normalization process includes consistent variable renaming and turning un-qualified  
function calls into qualified function calls.</p>
 
 </li>
 <li><p> 
?QUOTE(Str).</p>
 
 <p>Returns the AST representation of the code represented by <code>Str</code>, which can be an 
Erlang expression, an Erlang function or a function clause.</p>
 
 </li>
 <li><p> 
?SPLICE(Tree).</p>
 
 <p>Pretty-prints the AST <code>Tree</code>, and returns the string representation.</p>
 
 </li>
 <li><p> 
?MATCH(Template, Tree).</p>
 
 <p>Pattern matches the AST representation of <code>Template</code> with the AST <code>Tree</code>, and returns
 <code>false</code> if the pattern matching fails, and <code>{true, Binds}</code> if succeeds, where <code>Bind</code> represents the
 binding of meta-variables to AST nodes in the
 format: <code>[{MetaVariableName, syntaxTreee()}]</code>.</p>
 
 </li>
 <li><p> 
?FULL_TD(Rules, Scope).</p>
 
  <p>Traverse the AST in a topdown order, and for each node apply the first rule that  
succeeds; after a rule has been applied to a node, the subtrees of the node will  
continued to be traversed.</p>
 
 </li>
 <li>
 ?STOP_TD(Rules, Scope).
  Traverse the AST in a topdown order, and for each node apply the first rule that
  succeeds; after a rule has been applied to a node, the subtrees of the node will
  not to be traversed.
 </li>
 </ul>
  Some example refactorings implemented using the Wrangler API:
 <ul>
 <li>
 <a href="file:refac_swap_args.erl"> Swap arguments of a function;</a>.
 </li>
 <li>
 <a href="file:refac_keysearch_to_keyfind.erl"> replace the uses of lists:keysearch/3 with lists:keyfind/3; </a>
 </li>
 <li>
 <a href="file:refac_specialise.erl"> Specialise a function definition; </a>
 </li>
 <li>
 <a href="file:refac_apply_to_remote_call.erl"> Apply to remote function call; </a>
 </li>
 <li>
 <a href="file:refac_intro_import.erl">Introduce an import attribute; </a>
 </li>
 <li>
 <a href="file:refac_remove_import.erl">Remove an import attribute;</a>
 </li>
 <li>
 <a href="file:refac_list.erl"> Various list-related transformations;</a>
 </li>
 <li>
 <a href="file:refac_batch_rename_fun.erl"> Batch renaming of function names from camelCaseto camel_case. </a>
 </li>
 </ul>
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-fa">fa()</a></h3>
<p><tt>fa() = {<a href="#type-functionname">functionname()</a>, arity()}</tt></p>


<h3 class="typedecl"><a name="type-pos">pos()</a></h3>
<p><tt>pos() = {integer(), integer()}</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_to_export_after-3">add_to_export_after/3</a></td><td>Adds an entity <code>FAtoAdd</code> to the export list of an export attribute
      right after another entity <code>FA</code>; if <code>FA</code> is <code>none</code> then append
      the new entity to the end of the export list.</td></tr>
<tr><td valign="top"><a href="#bound_var_names-1">bound_var_names/1</a></td><td>Returns all the variable names that are declared within <code>Node</code>.</td></tr>
<tr><td valign="top"><a href="#bound_vars-1">bound_vars/1</a></td><td>Returns all the variables, including both variable name and define
       location, that are declared within <code>Node</code>.</td></tr>
<tr><td valign="top"><a href="#client_files-2">client_files/2</a></td><td>Returns those files, included in <code>SearchPaths</code>, which use/import
      some of the functions defined in <code>File</code>.</td></tr>
<tr><td valign="top"><a href="#defined_funs-1">defined_funs/1</a></td><td>Returns all the functions that are defined by an Erlang file.</td></tr>
<tr><td valign="top"><a href="#env_var_names-1">env_var_names/1</a></td><td>Returns all the variable names that are visible to <code>Node</code>.</td></tr>
<tr><td valign="top"><a href="#env_vars-1">env_vars/1</a></td><td>Returns all the variables, including both variable name and
      define location, that are visible to <code>Node</code>.</td></tr>
<tr><td valign="top"><a href="#equal-2">equal/2</a></td><td>Returns <code>true</code> if <code>Tree1</code> and <code>Tree2</code> are syntactically the
       same up to normalization.</td></tr>
<tr><td valign="top"><a href="#exported_funs-1">exported_funs/1</a></td><td>Returns all the functions that are exported by an Erlang file.</td></tr>
<tr><td valign="top"><a href="#exported_var_names-1">exported_var_names/1</a></td><td>Returns all the variable names that are declared within <code>Node</code>, and
     also used by the code outside <code>Node</code>.</td></tr>
<tr><td valign="top"><a href="#exported_vars-1">exported_vars/1</a></td><td>Returns all the variables, including both variable name and define
       location, that are declared within <code>Node</code>, and also used by the
       code outside <code>Node</code>.</td></tr>
<tr><td valign="top"><a href="#free_var_names-1">free_var_names/1</a></td><td>Returns all the variable names that are free within <code>Node</code>.</td></tr>
<tr><td valign="top"><a href="#free_vars-1">free_vars/1</a></td><td>Returns all the variables, including both variable name and define
       location, that are free within <code>Node</code>.</td></tr>
<tr><td valign="top"><a href="#fun_define_info-1">fun_define_info/1</a></td><td>Returns the MFA information attached a node that represents a
   function name or a qualified function name.</td></tr>
<tr><td valign="top"><a href="#get_ast-1">get_ast/1</a></td><td>Returns the AST representation of an Erlang file.</td></tr>
<tr><td valign="top"><a href="#get_module_info-1">get_module_info/1</a></td><td>Returns the module-level information about the Erlang file.</td></tr>
<tr><td valign="top"><a href="#imported_funs-1">imported_funs/1</a></td><td>Returns all the functions that are (auto)imported by an Erlang file.</td></tr>
<tr><td valign="top"><a href="#imported_funs-2">imported_funs/2</a></td><td>Returns all the functions that are imported from <code>ModuleName</code> by an Erlang file.</td></tr>
<tr><td valign="top"><a href="#inscope_funs-1">inscope_funs/1</a></td><td>Returns all the functions that are in-scope in the current module.</td></tr>
<tr><td valign="top"><a href="#insert_an_attr-2">insert_an_attr/2</a></td><td>Inserts an attribute before the first function definition.</td></tr>
<tr><td valign="top"><a href="#is_attribute-2">is_attribute/2</a></td><td>Returns <code>true</code> if <code>Node</code> represents an attribute
      of name <code>Name</code>.</td></tr>
<tr><td valign="top"><a href="#is_exported-2">is_exported/2</a></td><td>Returns true if <code>{FunName, Arity}</code> is exported by the Erlang module
      defined in <code>File</code>.</td></tr>
<tr><td valign="top"><a href="#is_expr-1">is_expr/1</a></td><td>Returns <code>true</code> if <code>Node</code> represents an expression (either a general
      expression or a guard expression), otherwise <code>false</code>.</td></tr>
<tr><td valign="top"><a href="#is_fun_name-1">is_fun_name/1</a></td><td>Returns <code>true</code> if a string is lexically a legal function name,
       otherwise <code>false</code>.</td></tr>
<tr><td valign="top"><a href="#is_guard_expr-1">is_guard_expr/1</a></td><td>Returns <code>true</code> if <code>Node</code> represents a guard expression, otherwise <code>false</code>.</td></tr>
<tr><td valign="top"><a href="#is_import-2">is_import/2</a></td><td>Returns <code>true</code> if <code>Node</code> represents an import attribute  that
      imports module <code>ModName</code></td></tr>
<tr><td valign="top"><a href="#is_pattern-1">is_pattern/1</a></td><td>Returns <code>true</code> if <code>Node</code> represents a pattern, otherwise <code>false</code>.</td></tr>
<tr><td valign="top"><a href="#is_var_name-1">is_var_name/1</a></td><td>Returns <code>true</code> if a string is lexically a legal variable name,
       otherwise <code>false</code>.</td></tr>
<tr><td valign="top"><a href="#make_new_name-2">make_new_name/2</a></td><td>Generates a new name by appending "_1" to the end of the 'BaseName'
       until the new name is not a member of <code>UsedNames</code>.</td></tr>
<tr><td valign="top"><a href="#mfa_to_fun_def-2">mfa_to_fun_def/2</a></td><td>Returns the function form that defines <code>MFA</code>; none is returns if no
  such function definition found.</td></tr>
<tr><td valign="top"><a href="#module_name-1">module_name/1</a></td><td>Returns the name of the module defined in <code>File</code>,.</td></tr>
<tr><td valign="top"><a href="#remove_from_import-2">remove_from_import/2</a></td><td>Remove <code>F/A</code> from the entity list of the import attribute
      represented by <code>Node</code>.</td></tr>
<tr><td valign="top"><a href="#start_end_loc-1">start_end_loc/1</a></td><td>Returns the start and end locations of an AST node or a sequence
      of AST node.</td></tr>
<tr><td valign="top"><a href="#syntax_category-1">syntax_category/1</a></td><td>Returns the syntax category of <code>Node</code>.</td></tr>
<tr><td valign="top"><a href="#syntax_context-1">syntax_context/1</a></td><td>Returns the syntax context of <code>Node</code>.</td></tr>
<tr><td valign="top"><a href="#tokenize-3">tokenize/3</a></td><td>Tokenises an Erlang file, and returns the tokens.</td></tr>
<tr><td valign="top"><a href="#variable_define_pos-1">variable_define_pos/1</a></td><td>Returns the define location of the variable represented by <code>Node</code>;
  [{0,0}] is returned is the variable is a free variable or <code>Node</code> is
  not properly annotated.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="add_to_export_after-3">add_to_export_after/3</a></h3>
<div class="spec">
<p><tt>add_to_export_after(Node::<a href="#type-attribute">attribute()</a>, FAtoAdd::<a href="#type-fa">fa()</a>, FA::<a href="#type-fa">fa()</a> | none) -&gt; <a href="#type-attribute">attribute()</a></tt><br></p>
</div><p>Adds an entity <code>FAtoAdd</code> to the export list of an export attribute
      right after another entity <code>FA</code>; if <code>FA</code> is <code>none</code> then append
      the new entity to the end of the export list.</p>

<h3 class="function"><a name="bound_var_names-1">bound_var_names/1</a></h3>
<div class="spec">
<p><tt>bound_var_names(Node::[<a href="#type-syntaxTree">syntaxTree()</a>] | <a href="#type-syntaxTree">syntaxTree()</a>) -&gt; [atom()]</tt><br></p>
</div><p>Returns all the variable names that are declared within <code>Node</code>.</p>

<h3 class="function"><a name="bound_vars-1">bound_vars/1</a></h3>
<div class="spec">
<p><tt>bound_vars(Nodes::[<a href="#type-syntaxTree">syntaxTree()</a>] | <a href="#type-syntaxTree">syntaxTree()</a>) -&gt; [{atom(), <a href="#type-pos">pos()</a>}]</tt><br></p>
</div><p>Returns all the variables, including both variable name and define
       location, that are declared within <code>Node</code>.</p>

<h3 class="function"><a name="client_files-2">client_files/2</a></h3>
<div class="spec">
<p><tt>client_files(File::<a href="#type-filename">filename()</a>, SearchPaths::[<a href="#type-filename">filename()</a> | <a href="#type-dir">dir()</a>]) -&gt; [<a href="#type-filename">filename()</a>]</tt><br></p>
</div><p>Returns those files, included in <code>SearchPaths</code>, which use/import
      some of the functions defined in <code>File</code>.</p>

<h3 class="function"><a name="defined_funs-1">defined_funs/1</a></h3>
<div class="spec">
<p><tt>defined_funs(File::<a href="#type-filename">filename()</a>) -&gt; [{atom(), integer()}]</tt><br></p>
</div><p>Returns all the functions that are defined by an Erlang file.</p>

<h3 class="function"><a name="env_var_names-1">env_var_names/1</a></h3>
<div class="spec">
<p><tt>env_var_names(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; [atom()]</tt><br></p>
</div><p>Returns all the variable names that are visible to <code>Node</code>.</p>

<h3 class="function"><a name="env_vars-1">env_vars/1</a></h3>
<div class="spec">
<p><tt>env_vars(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; [{atom(), <a href="#type-pos">pos()</a>}]</tt><br></p>
</div><p>Returns all the variables, including both variable name and
      define location, that are visible to <code>Node</code>.</p>

<h3 class="function"><a name="equal-2">equal/2</a></h3>
<div class="spec">
<p><tt>equal(Tree1::<a href="#type-syntaxTree">syntaxTree()</a>, Tree2::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; boolean()</tt><br></p>
</div><p>Returns <code>true</code> if <code>Tree1</code> and <code>Tree2</code> are syntactically the
       same up to normalization. The normalization process includes
       consistent variable renaming and turning un-qualified
       function calls into qualified function calls.</p>

<h3 class="function"><a name="exported_funs-1">exported_funs/1</a></h3>
<div class="spec">
<p><tt>exported_funs(File::<a href="#type-filename">filename()</a>) -&gt; [{atom(), integer()}]</tt><br></p>
</div><p>Returns all the functions that are exported by an Erlang file.</p>

<h3 class="function"><a name="exported_var_names-1">exported_var_names/1</a></h3>
<div class="spec">
<p><tt>exported_var_names(Node::[<a href="#type-syntaxTree">syntaxTree()</a>] | <a href="#type-syntaxTree">syntaxTree()</a>) -&gt; [atom()]</tt><br></p>
</div><p>Returns all the variable names that are declared within <code>Node</code>, and
     also used by the code outside <code>Node</code>.</p>

<h3 class="function"><a name="exported_vars-1">exported_vars/1</a></h3>
<div class="spec">
<p><tt>exported_vars(Nodes::[<a href="#type-syntaxTree">syntaxTree()</a>] | <a href="#type-syntaxTree">syntaxTree()</a>) -&gt; [{atom(), <a href="#type-pos">pos()</a>}]</tt><br></p>
</div><p>Returns all the variables, including both variable name and define
       location, that are declared within <code>Node</code>, and also used by the
       code outside <code>Node</code>.</p>

<h3 class="function"><a name="free_var_names-1">free_var_names/1</a></h3>
<div class="spec">
<p><tt>free_var_names(Node::[<a href="#type-syntaxTree">syntaxTree()</a>] | <a href="#type-syntaxTree">syntaxTree()</a>) -&gt; [atom()]</tt><br></p>
</div><p>Returns all the variable names that are free within <code>Node</code>.</p>

<h3 class="function"><a name="free_vars-1">free_vars/1</a></h3>
<div class="spec">
<p><tt>free_vars(Nodes::[<a href="#type-syntaxTree">syntaxTree()</a>] | <a href="#type-syntaxTree">syntaxTree()</a>) -&gt; [{atom(), <a href="#type-pos">pos()</a>}]</tt><br></p>
</div><p>Returns all the variables, including both variable name and define
       location, that are free within <code>Node</code>.</p>

<h3 class="function"><a name="fun_define_info-1">fun_define_info/1</a></h3>
<div class="spec">
<p><tt>fun_define_info(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; {<a href="#type-modulename">modulename()</a>, <a href="#type-functionname">functionname()</a>, arity()} | unknown</tt><br></p>
</div><p>Returns the MFA information attached a node that represents a
   function name or a qualified function name. <code>unknown</code> is returned is
   no MFA information is annotated to this node or <code>Node</code> does not
   represent a function name.</p>

<h3 class="function"><a name="get_ast-1">get_ast/1</a></h3>
<div class="spec">
<p><tt>get_ast(File::<a href="#type-filename">filename()</a>) -&gt; <a href="#type-syntaxTree">syntaxTree()</a> | {error, <a href="#type-errorInfo">errorInfo()</a>}</tt><br></p>
</div><p>Returns the AST representation of an Erlang file.</p>

<h3 class="function"><a name="get_module_info-1">get_module_info/1</a></h3>
<div class="spec">
<p><tt>get_module_info(File::<a href="#type-filename">filename()</a>) -&gt; #module_info{} | {error, <a href="#type-errorInfo">errorInfo()</a>}</tt><br></p>
</div><p>Returns the module-level information about the Erlang file.
  <pre>     -record(module_info,
          {module,
           exports,
           module_imports,
           imports,
           attributes,
           records,
           errors,
           warnings,
           functions}).</pre></p>

<h3 class="function"><a name="imported_funs-1">imported_funs/1</a></h3>
<div class="spec">
<p><tt>imported_funs(File::<a href="#type-filename">filename()</a>) -&gt; [{<a href="#type-modulename">modulename()</a>, <a href="#type-functionname">functionname()</a>, integer()}]</tt><br></p>
</div><p>Returns all the functions that are (auto)imported by an Erlang file.</p>

<h3 class="function"><a name="imported_funs-2">imported_funs/2</a></h3>
<div class="spec">
<p><tt>imported_funs(File::<a href="#type-filename">filename()</a>, ModuleName::<a href="#type-modulename">modulename()</a>) -&gt; [{<a href="#type-functionname">functionname()</a>, integer()}]</tt><br></p>
</div><p>Returns all the functions that are imported from <code>ModuleName</code> by an Erlang file.</p>

<h3 class="function"><a name="inscope_funs-1">inscope_funs/1</a></h3>
<div class="spec">
<p><tt>inscope_funs(FileOrModInfo::<a href="#type-filename">filename()</a>) -&gt; [{atom(), integer()}]</tt><br></p>
</div><p>Returns all the functions that are in-scope in the current module.
       An in-scope function could be an (auto-)imported function, or a
       function that is defined in the current module.</p>

<h3 class="function"><a name="insert_an_attr-2">insert_an_attr/2</a></h3>
<div class="spec">
<p><tt>insert_an_attr(AST::<a href="#type-syntaxTree">syntaxTree()</a>, Attr::<a href="#type-attribute">attribute()</a>) -&gt; <a href="#type-syntaxTree">syntaxTree()</a></tt><br></p>
</div><p>Inserts an attribute before the first function definition.</p>

<h3 class="function"><a name="is_attribute-2">is_attribute/2</a></h3>
<div class="spec">
<p><tt>is_attribute(Node::<a href="#type-syntaxTree">syntaxTree()</a>, Name::atom()) -&gt; boolean()</tt><br></p>
</div><p>Returns <code>true</code> if <code>Node</code> represents an attribute
      of name <code>Name</code>.</p>

<h3 class="function"><a name="is_exported-2">is_exported/2</a></h3>
<div class="spec">
<p><tt>is_exported(X1::{atom(), integer()}, FileOrModInfo::<a href="#type-filename">filename()</a>) -&gt; boolean()</tt><br></p>
</div><p>Returns true if <code>{FunName, Arity}</code> is exported by the Erlang module
      defined in <code>File</code>.</p>

<h3 class="function"><a name="is_expr-1">is_expr/1</a></h3>
<div class="spec">
<p><tt>is_expr(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; boolean()</tt><br></p>
</div><p>Returns <code>true</code> if <code>Node</code> represents an expression (either a general
      expression or a guard expression), otherwise <code>false</code>.</p>

<h3 class="function"><a name="is_fun_name-1">is_fun_name/1</a></h3>
<div class="spec">
<p><tt>is_fun_name(Name::string()) -&gt; boolean()</tt><br></p>
</div><p>Returns <code>true</code> if a string is lexically a legal function name,
       otherwise <code>false</code>.</p>

<h3 class="function"><a name="is_guard_expr-1">is_guard_expr/1</a></h3>
<div class="spec">
<p><tt>is_guard_expr(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; boolean()</tt><br></p>
</div><p>Returns <code>true</code> if <code>Node</code> represents a guard expression, otherwise <code>false</code>.</p>

<h3 class="function"><a name="is_import-2">is_import/2</a></h3>
<div class="spec">
<p><tt>is_import(Node::<a href="#type-syntaxTree">syntaxTree()</a>, ModName::atom()) -&gt; boolean()</tt><br></p>
</div><p>Returns <code>true</code> if <code>Node</code> represents an import attribute  that
      imports module <code>ModName</code></p>

<h3 class="function"><a name="is_pattern-1">is_pattern/1</a></h3>
<div class="spec">
<p><tt>is_pattern(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; boolean()</tt><br></p>
</div><p>Returns <code>true</code> if <code>Node</code> represents a pattern, otherwise <code>false</code>.</p>

<h3 class="function"><a name="is_var_name-1">is_var_name/1</a></h3>
<div class="spec">
<p><tt>is_var_name(Name::string()) -&gt; boolean()</tt><br></p>
</div><p>Returns <code>true</code> if a string is lexically a legal variable name,
       otherwise <code>false</code>.</p>

<h3 class="function"><a name="make_new_name-2">make_new_name/2</a></h3>
<div class="spec">
<p><tt>make_new_name(BaseName::atom(), UsedNames::[atom()]) -&gt; atom()</tt><br></p>
</div><p>Generates a new name by appending "_1" to the end of the 'BaseName'
       until the new name is not a member of <code>UsedNames</code>.</p>

<h3 class="function"><a name="mfa_to_fun_def-2">mfa_to_fun_def/2</a></h3>
<div class="spec">
<p><tt>mfa_to_fun_def(MFA::mfa(), FileOrTree::<a href="#type-filename">filename()</a> | syntaxTree) -&gt; <a href="#type-syntaxTree">syntaxTree()</a> | none</tt><br></p>
</div><p>Returns the function form that defines <code>MFA</code>; none is returns if no
  such function definition found.</p>

<h3 class="function"><a name="module_name-1">module_name/1</a></h3>
<div class="spec">
<p><tt>module_name(File::<a href="#type-filename">filename()</a>) -&gt; <a href="#type-modulename">modulename()</a></tt><br></p>
</div><p>Returns the name of the module defined in <code>File</code>,</p>

<h3 class="function"><a name="remove_from_import-2">remove_from_import/2</a></h3>
<div class="spec">
<p><tt>remove_from_import(Node::<a href="#type-attribute">attribute()</a>, FA::{<a href="#type-functionname">functionname()</a>, arity()}) -&gt; <a href="#type-attribute">attribute()</a></tt><br></p>
</div><p>Remove <code>F/A</code> from the entity list of the import attribute
      represented by <code>Node</code>.</p>

<h3 class="function"><a name="start_end_loc-1">start_end_loc/1</a></h3>
<div class="spec">
<p><tt>start_end_loc(Exprs::[<a href="#type-syntaxTree">syntaxTree()</a>] | <a href="#type-syntaxTree">syntaxTree()</a>) -&gt; {<a href="#type-pos">pos()</a>, <a href="#type-pos">pos()</a>}</tt><br></p>
</div><p>Returns the start and end locations of an AST node or a sequence
      of AST node. {{0,0},{0,0}} is returned if the AST nodes are not
      annotated with location information.</p>

<h3 class="function"><a name="syntax_category-1">syntax_category/1</a></h3>
<div class="spec">
<p><tt>syntax_category(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; pattern | expression | guard_expression | unknown</tt><br></p>
</div><p>Returns the syntax category of <code>Node</code>.</p>

<h3 class="function"><a name="syntax_context-1">syntax_context/1</a></h3>
<div class="spec">
<p><tt>syntax_context(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; atom()</tt><br></p>
</div><p>Returns the syntax context of <code>Node</code>.</p>

<h3 class="function"><a name="tokenize-3">tokenize/3</a></h3>
<div class="spec">
<p><tt>tokenize(File::<a href="#type-filename">filename()</a>, WithLayout::boolean(), TabWidth::integer()) -&gt; [<a href="#type-token">token()</a>] | {error, term()}</tt><br></p>
</div><p>Tokenises an Erlang file, and returns the tokens.</p>

<h3 class="function"><a name="variable_define_pos-1">variable_define_pos/1</a></h3>
<div class="spec">
<p><tt>variable_define_pos(Node::<a href="#type-syntaxTree">syntaxTree()</a>) -&gt; [<a href="#type-pos">pos()</a>]</tt><br></p>
</div><p>Returns the define location of the variable represented by <code>Node</code>;
  [{0,0}] is returned is the variable is a free variable or <code>Node</code> is
  not properly annotated.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, May 9 2011, 15:19:36.</i></p>
</body>
</html>
